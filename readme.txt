step 1: Learn the basics
    -[X] C++ Basics
    -[X] Time Complexity(Learn basics and then learn the next steps)

step 2: Build up logical thinking
    -[X] patterns

step 3: Learn standard template library for C++
     C++ STL
        -[X] vectors
        -[X] maps
        -[X] sets 
        
step 4: Know Basic Math
    -[X] reverse a number
    -[X] check palindrome
    -[X] GCD or HCF
    -[X] armstrong numbers
    -[X] print all divisors
    -[X] check prime numbers

step 5: Learn basic recursion
    -[X] understand recursion by printing something N times
    -[X] print name N times using recursion
    -[X] print 1 to N using recursion
    -[X] print N to 1 using recursion
    -[X] sum of first N numbers
    -[X] factorial of N numbers
    -[X] reverse an array
    -[X] check if a string is palindrome or not
    -[X] fibonacci number

step 6: Learn basic Hashing
    -[X] hashing theory
    -[X] counting frequency of array elements
    -[X] finding highest/lowest frequency elements

step 7: Learn important sorting techniques
    a) sorting - 1
        -[X] selection sort
        -[] bubble sort
        -[] insertion sort
    b) sorting - 2
        -[] merge sort
        -[] recursive bubble sort
        -[] recursive insertion sort
        -[] quick sort

step 8: Solve problems on arrays (easy -> medium -> hard)
    a) Easy
        -[X] largest element in an array
        -[X] second largest element in an array without sorting 
        -[X] check if array is sorted
        -[X] remove duplicate from the sorted array (two pointer problem)
        -[X] left rotate an array by one place
        -[X] left rotate an array by D place
        -[X] move zeros to end
        -[X] linear search
        -[X] find the union
        -[X] find missing number in an array
        -[X] maximum consecutive ones
        -[X] find the number that appears once and other number twice
        -[X] longest subarrays with given sum K(positives)
        -[X] longest subarrays with given sum K(positives and negatives)
    b) Medium 
        -[X] 2sum problem
        -[] sort an array of 0's , 1's and 2's
        -[] majority element (>n/2 times)
        -[] kadane's algorithm , maximum subarray sum
        -[] print subarray with maximum subarray sum(extended version of above problem)
        -[] stock buy and sell
        -[] rearrange the array elements in positive and negative items
        -[] next permutation
        -[] leaders in array problems
        -[] longest consecutive sequence in the array
        -[] set matrix zero
        -[] rotate matrix by 90 degree
        -[] print the matrix in spiral manner
        -[] count subarrays with the given sum
    c) Hard
        -[] pascal's triangle
        -[] majority elements(>n/3 times)
        -[] 3 sum problem
        -[] 4 sum problem
        -[] largest subarray with 0 sum
        -[] count number of subarray with given xor K
        -[] merge overlapping subintervals
        -[] merge two sorted array without extra space
        -[] find the repeating and missing number
        -[] count inversions
        -[] reverse pairs
        -[] maximum product subarrays

step 9: Binary search on 1D , 2D array and search space
    a) binary search on 1D array
        -[X] binary search to find x in sorted array
        -[X] implement lower bound
        -[X] implement upper bound
        -[X] search insert position
        -[] floor/ceil in sorted array
        -[] find the first or last occurances of a given number in a sorted array
        -[] find the occurances of a number in the sorted array with the duplicates
        -[] search in rotated sorted array 1
        -[] search in rotated sorted array 2
        -[] find minimum in rotated sorted array
        -[] find how many times a array have been rotated
        -[] single element in sorted array
        -[] find peek element
    b) binary search on answers
        -[] find square root of a number in log n
        -[] find the Nth root a number using binary search
        -[] koko eating bananas
        -[] minimum days to make M bouquets
        -[] find the smallest divisor
        -[] capacity to ship packages within D days
        -[] find the smallest divisor
        -[] aggressive cows
        -[] bool allocation problems
        -[] split array - largest sum
        -[] painter's partition
        -[] minimize max distance to gas station
        -[] median of 2 sorted array
        -[] kth element of two sorted array
    c) binary search on 2D arrays
        -[] find the row with maximum number of 1's
        -[] search in a 2D matrix
        -[] search in a row and column wise sorted matrix
        -[] find peek element(2D array)
        -[] matrix median

step 10: Strings (Basics and Medium)
    a) basic and easy string problems
        [X] remove outermost parenthesis
        [X] reverse words / palindrome check
        [X] largest odd number in a string
        [X] largest common prefix
        [X] isomorphic string
        [X] check whether one string is rotation of another
        [X] check if two strings are anagram of each other
    b) medium string problems
        [] sort character by frequency
        [] maximum nesting depth of paranthesis
        [] roman numbers to integers and vice-versa
        [] implement atoi
        [] count number of substring
        [] longest palindrome substring(without using DP)
        [] sum of beauty of all substring

step 11: Learn linked-list ( singly linked-list , doubly linked-list, easy -> medium -> hard )
    a) learn singly linked-list
        [X] introduction to linked-list learn about struct and how the node is represented
        [X] inserting a node in linked-list
        [X] deleting a node in linked-list
        [X] find the length of the linked-list(learn traversal)
        [X] search an element in linked-list
    b) learn doubly linked-list
        [X] introduction to doubly linked-list ,learn about struct and how it is represented
        [X] insert a node in doubly linked-list
        [X] delete a node in doubly linked-list
        [X] reverse a doubly linked-list
    c) medium problems on linked-list
        [] middle of linked-list(tortoise-hare method)
        [] reverse a linked-list(iterative)
        [] delete a loop in linked-list
        [] find the starting point of a linked-list
        [] length of loop in linked-list
        [] check if linked-list is palindrome or not
        [] segrregrate odd or even nodes in linked-list
        [] remove Nth node from the back of the linked-list
        [] delete the middle node from linked-list
        [] sort the linked-list
        [] sort the linked-list of 0's 1's and 2's by changing links
        [] find the intersection of Y linked-list
        [] add 1 to a number representing linked-list
        [] add 2 numbers in a linkedlist
    d) medium problems on doubly linked-list
        [] delete all occurance of key in doubly linked list
        [] find the pairs with given sum in doubly linke-list
        [] remove duplicates from sorted doubly linked-list
    e) hard problems on linked list
        [] remove linked-list in group of given size K
        [] rotate a linked-list
        [] flattering a linked-list
        [] clone a linked-list with random and next pointer

step 12: Recursion (pattern-wise)
    a) get a strong hold
        [X] recursion implementation of atoi()
        [X] pow(x,n)
        [] count good numbers
        [] sort a stack using recursion
        [] reverse a stack using recursion
    b) subsequent patterns
        [] generate all binary strings
        [] generate parenthesis
        [] print all subsequences / powerset
        [] learn all patterns of subsequences(theory)
        [] count all subsequences with sum K
        [] combination sum
        [] combination sum 2
        [] subset sum-1
        [] subset sum-2
        [] subset sum-3
        [] combination sum-3
        [] letter combination of a phone number
    c) string out all combos / hard
        [] palindrome partitioning
        [] word search
        [] N queens
        [] rat in a maze
        [] word break
        [] M coloring problem
        [] Sudoko solver
        [] expression add operators

step 13: Bit manipulation (concepts and problems)
    a) learn bit manipulation
        [X] introduction to bit manipulation(theory)
        [X] check if the ith bit is set or not
        [X] check if a number is odd or not
        [X] check if a number is power of 2 or not
        [] count of the number of set bits
        [X] set / unset the rightmost unset bit
        [X] swap two numbers
        [] divide two numbers without using multiplication , division or mod operator
    b) interview problems
        [] count the number of bits to be flipped to convert from A to B
        [] find the number that appears odd number of times
        [] power set
        [] find xor of number from L to R
        [] find the two number appearing odd number of times
    c) advanced maths
        [] print prime factors of a numbers
        [] all divisors of a number
        [] sieve of eratosthenes
        [] find prime factorization of a number using sieve
        [] power(n,x)

step 14: Stacks and Queues(learn pre-in post-fix, monotonic stack , implementation)
    a) learning
        [X] implementing stacks using arrays
        [X] implementing queues using arrays
        [X] implementing stacks using queues
        [X] implementing queues using stacks
        [X] implementing stacks using linked-list
        [X] implementing queues using linked-list
        [X] check for balanced parenthesis
        [X] implementing min stack
    b) prefix , postfix , infix conversion problems
        [X] infix to postfix conversion using stacks
        [X] prefix to infix conversion
        [X] prefix to postfix conversion
        [X] postfix to prefix conversion
        [X] postfix to infix conversion
        [X] convert infix to prefix notation
    c) Monotonic stacks / queues problems(very very very important )
        [X] next greater element
        [] next greater element 2
        [] next smaller element
        [] number of NGE's to right
        [] trapping rainwater 
        [] sum of subarray minimum
        [] asteroid collosion
        [] sum of subarray range
        [] remove K digits
        [] largest rectangle in a histogram
        [] maximal rectangles
    d) implementation problems
        [] sliding window maximum
        [] stock span problem
        [] the celebrity problem
        [] LRU cache (important)
        [] LRU cache
    
step 15: Slinding window and two pointer combined problems
    a) medium problems
        -[X] longest substring without repeating characters
        -[] maximum consecutive ones 3
        -[X] fruit into baskets
        -[X] longest repeating character replacement
        -[X] binary subarray with sum
        -[X] count number of nice subarrays
        -[X] number of substring containing all three characters
        -[X] maximum point you can obtain from card
    b) hard problems
        -[X] longest substring with atmost K distinct characters
        -[X] subarray with K distinct characters
        -[X] minimum window substring
        -[X] minimum window subsequence
    
step 16: Heaps (learing medium and hard problems)
    a) learning
        -[] introduction to priority queues using binary heaps
        -[] min and max heap implementation
        -[] check if an array represents a min-heap or not
        -[] convert min heap to max heap
    b) medium problems
        -[] Kth largest element in an array using priority queues
        -[] Kth smallest element in an array using priority queues
        -[] sort K sorted array
        -[] sort M sorted lists
        -[] replace each array element by its corresponding rank
        -[] task schedular
        -[] hands on straights
    c) hard problems
        -[] design twitter
        -[] connect 'n' ropes with minimum cost
        -[] Kth largest element in a stream of running integers
        -[] maximum sum combination
        -[] find median from data stream
        -[] K most frequent elements

step 17: Greedy algorithms (easy , medium and hard)
    a) easy problems
        -[X] assign cookies
        -[X] fractional knapsack problem
        -[] greedy algorithm to find the minimum number of coins
        -[X] lemonade change
        -[] valid parenthesis checker
    b) medium / hard
        -[] N meetings in one room
        -[X] jump game
        -[] jump game 2
        -[] minimum number of platforms required for a railway
        -[X] job sequencing problem
        -[] candy
        -[] problem for shortest job first CPU scheduling
        -[] insert interval
        -[] merge interval
        -[] non overlapping intervals

step 18: Binary trees (traversals , medium and hard problem)
    a) traversals
        -[X] introduction to trees
        -[X] binary tree representation in C++
        -[X] binary tree traversal in binary tree
        -[X] preorder traversal of a binary tree
        -[X] inorder traversal of a binary tree
        -[X] postorder traversal of a binary tree
        -[X] level order traversal in a spiral form
        -[X] iterative preorder traversal of binary tree
        -[X] iterative inorder traversal of binary tree
        -[] post order traversal of binary tree using 2 stacks
        -[] post order traversal of binary tree using 1 stacks
        -[] Preorder, Inorder, and Postorder Traversal in one Traversal
    b) medium problems
        -[] height of a binary tree
        -[] check if the binary tree is height balanced or not
        -[] diameter of binary tree
        -[] maximum path sum
        -[] check if two trees or identical or not
        -[] zig zac traversal of a binary tree
        -[] bounndary traversal of a binary tree
        -[] vertical order traversal of a binary tree
        -[] top view of a binary tree
        -[] bottom view of a binary tree
        -[] righ / left view of a binary tree
        -[] symmetrical binary tree
    c) hard problems
        -[] root to node path in binary tree
        -[] LCA in binary tree
        -[] maximum width of a binary tree
        -[] check for children sum property
        -[] print all nodes at a distance of K in a binary tree
        -[] minimum time taken to BURN the binary tree from a node
        -[] count total nodes in a COMPLETE binary tree
        -[] requirement needed to construct a unique binary tree(theory)
        -[] construct binary tree from inorder and preorder
        -[] construct binary tree from postordr and inorder traversal
        -[] serialize and deserialize binary tree
        -[] Morris preorder traversal of a binary tree
        -[] Morris inorder traversal of a binary tree
        -[] flatten binary tree to linked-list
    
step 19: Binary search tree (concepts and problems)
    a) concepts
        -[X] introduction to binary search tree
        -[X] search in a binary search tree
        -[X] find min/max in a BST
    b) practice problems
        -[] ceil in a binary search tree
        -[] floor in a binary search tree
        -[] insert a given node in a binary search tree
        -[] delete a node in a binary search tree
        -[] find the kth smallest / largest element in a binary search tree
        -[] check if a tree is BST or BT
        -[] LCA in binary search tree
        -[] construct a binary search tree from preorder traversal
        -[] inorder successor/predecessor in BST
        -[] merge 2 BST
        -[] two sum in BST / check if there exists a pair with sum K
        -[] recover BST / correct two nodes with BST swapped
        -[] largest BST in binary tree

step 20: Graphs(concepts and problems)
    a) learning
        -[X] graph and types
        -[X] graph representation in C++
        -[X] connected components / logical explaination
        -[X] breadth first search
        -[X] deapth first search
    b) problems on bfs and dfs
        -[] number of provinces
        -[] connected components in a matrix
        -[] rotten oranges
        -[] flood fill
        -[] cycle detection in undirected graph(bfs)
        -[] 0/1 matrix (bfs problem)
        -[] surrounded regions (dfs)
        -[] number of enclaves
        -[] word ladder - 1
        -[] word ladder -2
        -[] number of distinct islands(dfs)
        -[] bitpartitie graph(dfs)
        -[] cyclic detection in directed graph(dfs)
    c) topo sort and problems
        -[] tops sort
        -[] kahn's algorithm
        -[] cycle detection in directed graph(bfs)
        -[] course schedule -1
        -[] course schedule -2
        -[] find eventual safe states
        -[] alien dictionary
    d) shortest path algorithm and problems
        -[] shortest path in UG with unit weight
        -[] shortest path in DAG
        -[] Djisktra's Algorithm
        -[] Why priority Queue is used in Djisktra's Algorithm
        -[] Shortest path in a binary maze
        -[] Path with minimum effort
        -[] Cheapest flights within k stops
        -[] Network Delay time
        -[] Number of ways to arrive at destination
        -[] Minimum steps to reach end from start by performing multiplication and mod operations with array elements
        -[] Bellman Ford Algorithm
        -[] Floyd Warshal Algorithm
        -[] Find the city with the smallest number of neighbors in a threshold distance
    e) Minimum spaning tree / Disjoint set and problems
        -[] Minimum Spanning Tree
        -[] Prim's Algorithm
        -[] Disjoint Set [Union by Rank]
        -[] Disjoint Set [Union by Size]
        -[] Kruskal's Algorithm
        -[] Number of operations to make network connected
        -[] Most stones removed with same rows or columns
        -[] Accounts merge
        -[] Number of island II
        -[] Making a Large Island
        -[] Swim in rising water
    f) Other algorithms
        -[] Bridges in Graph
        -[] Articulation Point
        -[] Kosaraju's Algorithm

step 21: Dynamic Programming [patterns and problems]
    a) introduction to DP
        -[X] dynamic program introduction
    b) one dimenstional DP
        -[X] climbing stairs 
        -[] Frog Jump(DP-3)
        -[] Frog Jump with k distances(DP-4)
        -[] Maximum sum of non-adjacent elements (DP 5)
        -[] House Robber (DP 6)
    c) 2 dimenstional / 3 dimenstional DP and DP on grids
        -[] Ninja's Training (DP 7)
        -[] Grid Unique Paths : DP on Grids (DP8)
        -[] Grid Unique Paths 2 (DP 9)
        -[] Minimum path sum in Grid (DP 10)
        -[] Minimum path sum in Triangular Grid (DP 11)
        -[] Minimum/Maximum Falling Path Sum (DP-12)
        -[] 3-d DP : Ninja and his friends (DP-13)
    d) DP on subsequence
        -[] Subset sum equal to target (DP- 14)
        -[] Partition Equal Subset Sum (DP- 15)
        -[] Partition Set Into 2 Subsets With Min Absolute Sum Diff (DP- 16)
        -[] Count Subsets with Sum K (DP - 17)
        -[] Count Partitions with Given Difference (DP - 18)
        -[] Assign Cookies
        -[] Minimum Coins (DP - 20)
        -[] Target Sum (DP - 21)
        -[] Coin Change 2 (DP - 22)
        -[] Unbounded Knapsack (DP - 23)
        -[] Rod Cutting Problem | (DP - 24)
    e) DP on strings
        -[] Longest Common Subsequence | (DP - 25)
        -[] Print Longest Common Subsequence | (DP - 26)
        -[] Longest Common Substring | (DP - 27)
        -[] Longest Palindromic Subsequence | (DP-28)
        -[] Minimum insertions to make string palindrome | DP-29
        -[] Minimum Insertions/Deletions to Convert String | (DP- 30)
        -[] Shortest Common Supersequence | (DP - 31)
        -[] Distinct Subsequences| (DP-32)
        -[] Edit Distance | (DP-33)
        -[] Wildcard Matching | (DP-34)
    f) DP on stocks
        -[] Best Time to Buy and Sell Stock |(DP-35)
        -[] Buy and Sell Stock - II|(DP-36)
        -[] Buy and Sell Stocks III|(DP-37)
        -[] Buy and Stock Sell IV |(DP-38)
        -[] Buy and Sell Stocks With Cooldown|(DP-39)
        -[] Buy and Sell Stocks With Transaction Fee|(DP-40)
    g) Dp on Longest Inscreasing Subsequence
        -[] Longest Increasing Subsequence |(DP-41)
        -[] Printing Longest Increasing Subsequence|(DP-42)
        -[] Longest Increasing Subsequence |(DP-43)
        -[] Largest Divisible Subset|(DP-44)
        -[] Longest String Chain|(DP-45)
        -[] Longest Bitonic Subsequence |(DP-46)
        -[] Number of Longest Increasing Subsequences|(DP-47)
    h) Matrix Chain multiplication / Partition DP
        -[] Matrix Chain Multiplication|(DP-48)
        -[] Matrix Chain Multiplication | Bottom-Up|(DP-49)
        -[] Minimum Cost to Cut the Stick|(DP-50)
        -[] Burst Balloons|(DP-51)
        -[] Evaluate Boolean Expression to True|(DP-52)
        -[] Palindrome Partitioning - II|(DP-53)
        -[] Partition Array for Maximum Sum|(DP-54)
    i) DP on squares
        -[] Maximum Rectangle Area with all 1's|(DP-55)
        -[] Count Square Submatrices with All Ones|(DP-56)

step 21: Tries 
    a) theory
        -[] Implement TRIE | INSERT | SEARCH | STARTSWITH
    b) problems
        -[] Implement Trie - 2 (Prefix Tree)
        -[] Longest String with All Prefixes
        -[] Number of Distinct Substrings in a String
        -[] Bit PreRequisites for TRIE Problems
        -[] Maximum XOR of two numbers in an array
        -[] Maximum XOR With an Element From Array

step 22: Strings
    a) Hard Problems
        -[] Minimum number of bracket reversals needed to make an expression balanced
        -[] Count and say
        -[] Hashing In Strings | Theory
        -[] Rabin Karp
        -[] Z-Function
        -[] KMP algo / LPS(pi) array
        -[] Shortest Palindrome
        -[] Longest happy prefix
        -[] Count palindromic subsequence in given string
